'''
Testing routine for creating playlists in shotgun linked to versions associated with shots

use action menu via web with POST script that is already written

from POST, take the list of Shots

create a new playlist
	name will be date based unless I can figure out how to ask user

for each shot in Shots
	get Version from Current-version field (try find with all id's)
	create a list of Versions
	
attach each Version to playlist


*** Questions for client:***
In the Playlist, do you want to add a custom field that can be used to track the script user? (Script User - Entity, User)
    NO!
    
What value do you want to set for the initial Status (the short code - like  "act" for Active or "opn" for Open
    'act' ( field name - 'sg_status')
    
What Type do you want to set? (should be a sting value like "Client" or "Dailies"
    'Edit' (Field 'sg_type' NOTE - client has to make sure to edit field to accept this data!)
    
Other than a date/time to identify the playlist, what else do you want in the name? (I have not yet found a way to ask for a name but I will look into it more when I have a working script)
    date and time for now and then use a web form to ask... *(field code  = 'code')
    
Do you want to set a default description or leave it blank (assuming that it can't be filled in at run-time.
    blank unless it can be filled in at run time (field code 'description')
   
********** SPEC ***********
What we are looking for, is a feature to create a playlist from within the shot list view ... 
    we wanna have a ActionMenu script that can build a playlist of the selected shots and automatically 
    look for a version based on one of the following :

1: A custom field we created under shots > current_version ... 
        in order to set the current version, we would also need a ActionMenu script 
        under the version page - where you can "Set as Current"
2: Newest version related to this shot

These two options should be two diffrent ActionMenu items (scripts)
'''
#TEST DATA
shot_ids = [ 876, 877, 878, 879, 880 ]
PROJECT_ID= 64
script_user_id = 45 # some artist user






# #mark Imports

from shotgun_api3 import Shotgun
from pprint import pprint
from os import path
import ConfigParser
import datetime

# #mark default global variables
CONFIG_FILE = 'sgkeys.cfg' #config file assumed in same directory as script
THIS_SCRIPT_CONFIG = 'create_playlist'
CURRENT_VERSION_FIELD = 'sg_current_version' # the Shot field that contains an entity link to the 'current' Version
LATEST_VERSION_FIELD = 'sg_latest_version' # the Shot field that contains an entity link to the 'latest version' - see screenshots
PLAYLIST_STATUS = 'act'
PLAYLIST_TYPE = 'Edit'

# #mark Load Config Data
if path.isfile(CONFIG_FILE): #test for existence of config file
    config = ConfigParser.RawConfigParser()
    config.read(CONFIG_FILE)
    SERVER_PATH = config.get(THIS_SCRIPT_CONFIG, 'SERVER_PATH')
    SCRIPT_USER = config.get(THIS_SCRIPT_CONFIG,'SCRIPT_USER')
    SCRIPT_KEY = config.get(THIS_SCRIPT_CONFIG,'SCRIPT_KEY')

# #mark Set-Up Variables
sg = Shotgun(SERVER_PATH, SCRIPT_USER, SCRIPT_KEY)
version_ids=[] # start with an empty list and then add to it as we get information
now = datetime.datetime.now()
playlist_name = now.strftime('%b %d %H:%M:%S') # use a time that is granular enough to (probably) avoid collisions
playlist_description = 'This playlist generated by the Action Menu Script'
shot_fields = ['id',  'entity', 'sg_asset_type',  CURRENT_VERSION_FIELD] # version id, shot info, "version"
version_fields = ['id', 'entity']




try:
    print '<H1>Processing request to create playlist from current version of these shots...</H1>'
    print '</br>'
    print '</br>'
    success = True # keep track of errors so that true success for all requests can be reported to the user
    
    # first, look to see if there is a current version in the shot
    # if not, then find all the versions that link to that shot and return the most recent
    
    shot_filters = [
    ['project','is',{'type':'Project','id':PROJECT_ID}],
    ['id', 'in', ] + shot_ids
    ]
    
    # #mark First get the version so that the linked shot can then be accessed.
    assets= sg.find("Shot", shot_filters, shot_fields)

    # did anything get returned? if not then error out...
    if len(assets) < 1:
        print '</br>'
        print "<b>Shotgun Server Did Not Return Any Shots! </b>"
        print '</br>'
        print '</br>'            
        success = False


    else: # something was returned, process it!
                        
        for an_asset in assets: # get the appropriate version and append it to the version list
            if an_asset[CURRENT_VERSION_FIELD]: # there is a valid version in the field, append it to the list:
                version_ids.append(an_asset[CURRENT_VERSION_FIELD]['id']) # put the returned asset id onto the list
            
            else : # there was no version in the field so it's going to be work to get it...
                order_by_date = [{'field_name':'created_at','direction':'desc'}, ] # order the output of the find MUST be a list!
                linked_shot = { 'type' : 'Shot' , 'id' : an_asset['id']} # get the id from the current asset we are looking at and use it to create a shot dict
                version_filters = [
                                ['project','is',{'type':'Project','id':PROJECT_ID}],
                                ['entity', 'is', linked_shot ] 
                                ]
                linked_versions = sg.find('Version', version_filters, version_fields,order_by_date)
                version_ids.append(linked_versions[0]['id']) # use zero index to get the most recent version linked to the shot because of sort order
                
                
        #end for an-asset in assets...
        
        # #mark Create the New Playlist!
        # ----------------------------------------------
        # Create new Version 
        # ----------------------------------------------
        # project_id = 4 # Demo Project
        # data = {
        #     'project': {'type':'Project','id':project_id},
        #     'code':'JohnnyApple_Design01_FaceFinal',
        #     'description': 'fixed rig per director final notes',
        #     'id': 6007
        #     'sg_status_list':'rev',
        #     'entity': {'type':'Asset','id':123},
        #     'type': 'Version',
        #     'user': {'type':'HumanUser','id':'165'},
        #     }
        # version = sg.create("Version",data,return_fields=[''])
        # pprint(version)

        playlist_user = {'type' : 'HumanUser' , 'id' : script_user_id}
        version_list = [ {'type' : 'Version', 'id' : x } for x in version_ids ]
        
        data = {
            'project': { 'type' : 'Project' , 'id' : PROJECT_ID } ,
            'code' : playlist_name ,
            'description' : playlist_description ,
            'sg_status' : PLAYLIST_STATUS ,
            'versions' : version_list ,
            'sg_type' : PLAYLIST_TYPE ,
            'sg_script_user' : playlist_user ,
            'sg_date_and_time' : now
            }
        playlist = sg.create("Playlist",data)
        pprint(playlist)
                
#             entity_type = an_asset['entity']['type'] # should always be 'Shot'!
#             if entity_type == 'Shot': # we always expect a shot but OK to test
#                 shot_id = an_asset['entity']['id']
#                 linked_version = { 'type' : 'Version' , 'id' : a_version_id } 
#                 data = { CURRENT_VERSION_FIELD : linked_version }
# 
#                 changed_asset = sg.update("Shot", shot_id, data) 
#                 print 'Shot %i Has Been Updated Successfully' % shot_id     
#                 print '</br>'     
#             else:
#                 success = False
#                 print('version %s is linked to something other than a shot?' % a_version_id)
#                 print '</br>'


    if success: #everything has gone well and the user gets a message
                    print '</br>'
                    print "<b>All requests successfully processed</b>"
                    print '</br>'

    print "</body>"
    print "</html>"



except Exception, e:
    print "Something Drastic Has Gone Wrong!"
    print '</br>'
    print "Check that all versions are linked to shots"
    print '</br>'
    print "The following message MAY shed some light on it..."
    print '</br>'
    print "%s" % e
    print '</br>'
    print "</body>"
    print "</html>"
